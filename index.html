<!--
PaperAnimator-clone
Single-file HTML app that replicates core *functionality* of PaperAnimator:
- Upload an image
- Paint a mask (brush) to separate subject from background (manual mask)
- Create a paper-style edge using an SVG filter
- Preview animated paper fold/out effect
- Export animation as a WebM video (client-side) without server

Limitations:
- This is an achievable free, client-side approximation. It uses a manual mask brush — no AI background removal.
- Exports WebM (widely supported). If you need MP4, transcode externally.

How to use:
1. Save this file as `index.html`.
2. Open locally in Chrome/Edge/Firefox (some browsers may block saving files from MediaRecorder without HTTPS).
3. Optionally host for free on GitHub Pages (create a repo, upload index.html, enable Pages).


Author: Generated for you
--><!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PaperAnimator — Free Client-side Clone</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#ef9e4a;--muted:#9aa4b2;color-scheme:dark}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071226 0%,#081826 60%);color:#e6eef6;display:flex;align-items:flex-start;gap:18px;padding:24px}
    .app{display:flex;gap:18px;width:100%;max-width:1200px;margin:auto}
    .controls{width:360px;background:rgba(255,255,255,0.04);padding:16px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    h1{font-size:18px;margin:0 0 12px 0}
    label{display:block;margin-top:10px;font-size:13px;color:var(--muted)}
    input[type=file]{display:block}
    .preview{flex:1;background:rgba(255,255,255,0.02);padding:12px;border-radius:12px;min-height:480px;display:flex;flex-direction:column;align-items:center;justify-content:center}
    .canvas-wrap{position:relative;width:720px;height:480px;background:linear-gradient(180deg,#f7f7f7 0%,#eee 100%);display:flex;align-items:center;justify-content:center;border-radius:6px;overflow:hidden}
    canvas{image-rendering:auto;position:absolute;left:0;top:0}
    #outputCanvas{position:relative;z-index:5}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    button,select{background:#0b1220;border:1px solid rgba(255,255,255,0.06);color:#e6eef6;padding:8px 10px;border-radius:8px;font-size:14px}
    .muted{color:var(--muted);font-size:13px;margin-top:6px}
    .small{font-size:13px}
    input[type=range]{width:100%}
    .hint{font-size:12px;color:var(--muted);margin-top:8px}
    footer{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <div class="app">
    <aside class="controls">
      <h1>PaperAnimator — free clone</h1><label>Upload image</label>
  <input id="fileInput" type="file" accept="image/*">

  <label>Brush size <span id="brushVal" class="small">24</span></label>
  <input id="brushSize" type="range" min="4" max="100" value="24">

  <label>Brush mode</label>
  <div class="toolbar">
    <button id="paintBtn">Paint</button>
    <button id="eraseBtn">Erase</button>
    <button id="autoBtn">Auto-fill (simple)</button>
    <button id="clearMask">Clear mask</button>
  </div>

  <label>Animation</label>
  <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
    <select id="animType">
      <option value="fold">Fold-out</option>
      <option value="float">Float & rotate</option>
      <option value="zoom">Zoom & reveal</option>
    </select>
    <input id="duration" type="number" min="1" max="30" value="4" style="width:80px">s
  </div>

  <label>Paper edge amount <span id="edgeVal" class="small">18</span></label>
  <input id="edgeAmount" type="range" min="0" max="60" value="18">

  <div class="toolbar" style="margin-top:12px">
    <button id="previewBtn">Preview</button>
    <button id="recordBtn">Export WebM</button>
    <button id="downloadPNG">Download PNG</button>
  </div>

  <div class="hint">How it works: upload image → paint mask (subject) → preview animation → export video.</div>
  <footer>Host for free: upload this single file to GitHub Pages. Works fully client-side.</footer>
</aside>

<section class="preview">
  <div class="canvas-wrap" id="stage">
    <!-- outputCanvas shows final composition -->
    <canvas id="outputCanvas" width="720" height="480"></canvas>
    <!-- imageCanvas holds original image pixels (not shown) -->
    <canvas id="imageCanvas" width="720" height="480" style="display:none"></canvas>
    <!-- maskCanvas for brush painting (top during editing) -->
    <canvas id="maskCanvas" width="720" height="480"></canvas>

    <!-- Invisible video element used when recording -->
    <video id="previewVideo" playsinline style="display:none"></video>

    <!-- SVG filter for paper edge -->
    <svg width="0" height="0" style="position:absolute">
      <filter id="paperEdge">
        <feTurbulence baseFrequency="0.8" numOctaves="2" result="noise" seed="2"/>
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="20" xChannelSelector="R" yChannelSelector="G"/>
      </filter>
    </svg>
  </div>

  <div class="toolbar" style="margin-top:12px;align-self:flex-start">
    <div class="muted">Tips: paint the subject in white on the mask. Erase to remove. Use Auto-fill for basic center subject detect.</div>
  </div>
</section>

  </div>  <script>
  // ---- Basic app state ----
  const fileInput = document.getElementById('fileInput');
  const imageCanvas = document.getElementById('imageCanvas');
  const maskCanvas = document.getElementById('maskCanvas');
  const outputCanvas = document.getElementById('outputCanvas');
  const previewVideo = document.getElementById('previewVideo');
  const ctxImg = imageCanvas.getContext('2d');
  const ctxMask = maskCanvas.getContext('2d');
  const ctxOut = outputCanvas.getContext('2d');

  const brushSizeInput = document.getElementById('brushSize');
  const brushVal = document.getElementById('brushVal');
  const edgeAmount = document.getElementById('edgeAmount');
  const edgeVal = document.getElementById('edgeVal');
  const animType = document.getElementById('animType');
  const durationInput = document.getElementById('duration');

  let img = new Image();
  let drawing=false; let mode='paint';
  let brushSize = Number(brushSizeInput.value);
  brushVal.textContent = brushSize;
  brushSizeInput.addEventListener('input', ()=>{ brushSize = Number(brushSizeInput.value); brushVal.textContent=brushSize});
  edgeAmount.addEventListener('input', ()=> edgeVal.textContent = edgeAmount.value);

  // Set canvas sizes
  function setCanvasSize(w=720,h=480){[imageCanvas,maskCanvas,outputCanvas].forEach(c=>{c.width=w; c.height=h;});}
  setCanvasSize();

  // Load image
  fileInput.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f);
    img = new Image(); img.onload = ()=>{
      // Fit to canvas while preserving aspect
      const cw = outputCanvas.width, ch = outputCanvas.height;
      const scale = Math.min(cw/img.width, ch/img.height);
      const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
      // clear
      ctxImg.clearRect(0,0,cw,ch);
      ctxMask.clearRect(0,0,cw,ch);
      // center
      const x = Math.round((cw-nw)/2), y = Math.round((ch-nh)/2);
      ctxImg.drawImage(img, x,y, nw,nh);
      // initial mask: transparent
      ctxMask.fillStyle = 'rgba(0,0,0,0)'; ctxMask.clearRect(0,0,cw,ch);
      renderOutput();
    };
    img.src = url;
  });

  // Mask painting
  let last={x:0,y:0};
  maskCanvas.style.zIndex = 10;
  maskCanvas.addEventListener('pointerdown', e=>{drawing=true; maskCanvas.setPointerCapture(e.pointerId); const r=maskCanvas.getBoundingClientRect(); last.x = e.clientX - r.left; last.y = e.clientY - r.top; drawBrush(last.x,last.y);});
  maskCanvas.addEventListener('pointermove', e=>{ if(!drawing) return; const r=maskCanvas.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; drawLine(last.x,last.y,x,y); last.x=x; last.y=y;});
  maskCanvas.addEventListener('pointerup', e=>{drawing=false; try{maskCanvas.releasePointerCapture(e.pointerId);}catch(e){}; renderOutput();});

  function drawBrush(x,y){ctxMask.beginPath(); ctxMask.fillStyle = (mode==='paint')?'rgba(255,255,255,1)':'rgba(0,0,0,1)'; ctxMask.arc(x,y,brushSize/2,0,Math.PI*2); ctxMask.fill();}
  function drawLine(x1,y1,x2,y2){ctxMask.strokeStyle=(mode==='paint')?'rgba(255,255,255,1)':'rgba(0,0,0,1)'; ctxMask.lineWidth = brushSize; ctxMask.lineCap='round'; ctxMask.beginPath(); ctxMask.moveTo(x1,y1); ctxMask.lineTo(x2,y2); ctxMask.stroke();}

  document.getElementById('paintBtn').addEventListener('click', ()=>{mode='paint';});
  document.getElementById('eraseBtn').addEventListener('click', ()=>{mode='erase';});
  document.getElementById('clearMask').addEventListener('click', ()=>{ctxMask.clearRect(0,0,maskCanvas.width,maskCanvas.height); renderOutput();});

  // Simple auto-fill detection: center-weighted thresholding to pick subject-like area
  document.getElementById('autoBtn').addEventListener('click', ()=>{
    const cw = imageCanvas.width, ch = imageCanvas.height;
    const imgd = ctxImg.getImageData(0,0,cw,ch);
    const data = imgd.data;
    const mask = ctxMask.createImageData(cw,ch);
    // Compute center
    const cx=cw/2, cy=ch/2;
    for(let y=0;y<ch;y++){
      for(let x=0;x<cw;x++){
        const i=(y*cw+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        // brightness
        const bright = (r+g+b)/3;
        // distance weighting
        const d = Math.hypot(x-cx, y-cy);
        const maxd = Math.hypot(cx,cy);
        const weight = 1 - (d/maxd);
        // heuristics: bright subjects at center
        if(bright>50 && weight>0.3){ mask.data[i]=255; mask.data[i+1]=255; mask.data[i+2]=255; mask.data[i+3]=255;} else {mask.data[i+3]=0}
      }
    }
    ctxMask.putImageData(mask,0,0);
    renderOutput();
  });

  // Compose output by applying mask as alpha to image and drawing paper edge effect
  function renderOutput(){
    const cw = outputCanvas.width, ch = outputCanvas.height;
    ctxOut.clearRect(0,0,cw,ch);
    // Draw background (paper color)
    ctxOut.fillStyle = '#fff'; ctxOut.fillRect(0,0,cw,ch);
    // create an offscreen canvas where we apply alpha
    const off = document.createElement('canvas'); off.width=cw; off.height=ch;
    const offCtx = off.getContext('2d');
    // draw image
    offCtx.drawImage(imageCanvas,0,0);
    // get mask and apply as alpha
    const imgData = offCtx.getImageData(0,0,cw,ch);
    const maskData = ctxMask.getImageData(0,0,cw,ch);
    for(let i=0;i<imgData.data.length;i+=4){
      // mask alpha is taken from maskData's red channel
      const alpha = maskData.data[i] / 255; // 0..1
      imgData.data[i+3] = Math.round(alpha * 255);
    }
    offCtx.putImageData(imgData,0,0);

    // create texture for paper edge by drawing displacement via SVG filter - we'll fallback to simple shadow
    // To apply svg filter to a canvas, draw the image into DOM <img> using toDataURL and apply CSS filter
    const dataURL = off.toDataURL();
    const tmpImg = new Image();
    tmpImg.onload = ()=>{
      // Draw background again
      ctxOut.fillStyle = '#fff'; ctxOut.fillRect(0,0,cw,ch);
      // create temporary element to host filter
      // We'll render onto the output canvas directly but generate an edge mask using canvas operations to mimic torn edge
      // Simpler approach: draw the cutout, then stroke its alpha boundary
      ctxOut.drawImage(tmpImg,0,0);

      // create edge by sampling alpha and drawing a jittery stroke around opaque areas
      const alphaData = offCtx.getImageData(0,0,cw,ch).data;
      const edge = Number(edgeAmount.value);
      ctxOut.save();
      ctxOut.globalCompositeOperation = 'destination-over';
      // shadow to emphasize paper edge
      ctxOut.shadowColor = 'rgba(0,0,0,0.12)'; ctxOut.shadowBlur = 12; ctxOut.shadowOffsetX = 4; ctxOut.shadowOffsetY = 6;
      // we simulate edge by drawing blurred alpha mask behind
      const maskCanvas2 = document.createElement('canvas'); maskCanvas2.width=cw; maskCanvas2.height=ch; const mctx = maskCanvas2.getContext('2d');
      const mImg = mctx.createImageData(cw,ch);
      for(let i=0, j=0;i<alphaData.length;i+=4,j++){
        const a = alphaData[i+3]; mImg.data[i]=255; mImg.data[i+1]=255; mImg.data[i+2]=255; mImg.data[i+3]=a;
      }
      mctx.putImageData(mImg,0,0);
      // blur by drawing scaled down/up technique (cheap blur)
      const scale = Math.max(1, Math.round(edge/6));
      const w2 = Math.max(1, Math.round(cw/scale)), h2 = Math.max(1, Math.round(ch/scale));
      const tmp = document.createElement('canvas'); tmp.width=w2; tmp.height=h2; const tctx=tmp.getContext('2d');
      tctx.drawImage(maskCanvas2,0,0,w2,h2);
      for(let k=0;k<3;k++) tctx.drawImage(tmp,0,0,w2,h2);
      ctxOut.drawImage(tmp, -edge/2, -edge/2, cw+edge, ch+edge);
      ctxOut.restore();

      // draw the cutout on top
      ctxOut.drawImage(tmpImg,0,0);

      // overlay a subtle paper texture (generated)
      drawPaperTexture(ctxOut,cw,ch);

      // apply initial transform styles for animation: we'll not animate on canvas here; CSS/DOM anim will animate wrapper when previewing
    };
    tmpImg.src = dataURL;
  }

  function drawPaperTexture(ctx,w,h){
    ctx.save(); ctx.globalAlpha = 0.06;
    for(let i=0;i<2000;i++){
      const x = Math.random()*w, y=Math.random()*h, s = Math.random()*1.2; ctx.fillRect(x,y,0.6*s,0.6*s);
    }
    ctx.restore();
  }

  // Preview: animate using offscreen frames and CSS on canvas wrapper
  const stage = document.getElementById('stage');
  document.getElementById('previewBtn').addEventListener('click', ()=>{
    // create animation by applying CSS transform to the outputCanvas
    const type = animType.value; const dur = Math.max(1, Number(durationInput.value));
    // reset
    outputCanvas.style.transition = 'none'; outputCanvas.style.transform = 'none';
    void outputCanvas.offsetWidth;
    if(type==='fold'){
      outputCanvas.style.transformOrigin = 'left center';
      outputCanvas.style.transition = `transform ${dur}s ease-in-out`;
      outputCanvas.style.transform = 'perspective(800px) rotateY(-80deg) translateX(-40px) scale(0.9)';
      setTimeout(()=>{ outputCanvas.style.transform = 'perspective(800px) rotateY(0deg) translateX(0) scale(1)'; },50);
    } else if(type==='float'){
      outputCanvas.style.transition = `transform ${dur}s ease-in-out`;
      outputCanvas.style.transform = 'translateY(-40px) rotate(-8deg) scale(1.02)';
      setTimeout(()=>{ outputCanvas.style.transform = 'translateY(0) rotate(0) scale(1)'; },50);
    } else if(type==='zoom'){
      outputCanvas.style.transition = `transform ${dur}s cubic-bezier(.22,.9,.32,1)`;
      outputCanvas.style.transform = 'scale(1.06) translateY(-20px)';
      setTimeout(()=>{ outputCanvas.style.transform = 'scale(1) translateY(0)'; },50);
    }
  });

  // Export: record canvas animation as WebM using MediaRecorder
  document.getElementById('recordBtn').addEventListener('click', async ()=>{
    const dur = Math.max(1, Number(durationInput.value));
    // prepare animation frames: we'll programmatically animate transforms and record
    const stream = outputCanvas.captureStream(60);
    const rec = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=vp9'});
    const chunks = [];
    rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    rec.onstop = ()=>{
      const blob = new Blob(chunks, {type:'video/webm'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download = 'paper_anim.webm'; a.click(); URL.revokeObjectURL(url);
    };
    rec.start();
    // trigger the preview animation but smooth over the whole duration
    const type = animType.value;
    // set initial
    outputCanvas.style.transition = `transform ${dur}s ease-in-out`;
    if(type==='fold'){ outputCanvas.style.transformOrigin='left center'; outputCanvas.style.transform='perspective(800px) rotateY(-80deg) translateX(-40px) scale(0.9)'; setTimeout(()=> outputCanvas.style.transform='perspective(800px) rotateY(0deg) translateX(0) scale(1)',50);} 
    else if(type==='float'){ outputCanvas.style.transform='translateY(-40px) rotate(-8deg) scale(1.02)'; setTimeout(()=> outputCanvas.style.transform='translateY(0) rotate(0) scale(1)',50);} 
    else { outputCanvas.style.transform='scale(1.06) translateY(-20px)'; setTimeout(()=> outputCanvas.style.transform='scale(1) translateY(0)',50);} 

    // stop after duration
    setTimeout(()=>{ rec.stop(); // reset transform
      setTimeout(()=>{ outputCanvas.style.transition='none'; outputCanvas.style.transform='none'; },200);
    }, dur*1000 + 200);
  });

  // Download static PNG of current output
  document.getElementById('downloadPNG').addEventListener('click', ()=>{
    const url = outputCanvas.toDataURL('image/png'); const a = document.createElement('a'); a.href=url; a.download='paper_still.png'; a.click();
  });

  // Initial draw
  renderOutput();
  </script></body>
</html>
